<!DOCTYPE html>
<html lang="en">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@3.3.0"></script>

<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Options + Technical Dashboard — Stable Release</title>

<!-- Chart.js & Financial plugin -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@3.3.0"></script>

<style>
  :root{
    --bg:#f6f7fb; --fg:#2b3a55; --card:#fff; --muted:#6b7280; --border:#e7e9ef;
    --good-bg:#eefaf0; --good-fg:#2f6b33; --bad-bg:#fff1f2; --bad-fg:#9c0006; --neutral-bg:#e9eef6; --neutral-fg:#2b3a55;
  }
  @media (prefers-color-scheme: dark){
    :root{
      --bg:#101317; --fg:#e5e7eb; --card:#151a21; --muted:#9aa4b2; --border:#273244;
      --good-bg:#0e2a18; --good-fg:#b7f3c6; --bad-bg:#2a1113; --bad-fg:#f7b3b8; --neutral-bg:#1b2431; --neutral-fg:#d8dee9;
    }
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--fg);font-family:"Segoe UI",system-ui,Arial,sans-serif}
  header{text-align:center;padding:18px 10px}
  h1{margin:0 0 6px}
  #wrap{max-width:1150px;margin:0 auto;padding:0 14px 36px}
  .row{display:grid;grid-template-columns:2fr 1fr;gap:14px}
  @media(max-width:980px){.row{grid-template-columns:1fr}}
  .card{background:var(--card);border:1px solid var(--border);border-radius:12px;box-shadow:0 1px 6px rgba(0,0,0,.05)}
  .card h3{margin:0;padding:12px 16px;border-bottom:1px solid var(--border);font-size:16px}
  .card .body{padding:12px 16px}
  #controls{display:flex;gap:8px;justify-content:center;align-items:center;margin-bottom:12px;flex-wrap:wrap}
  input,button{padding:8px 12px;border:1px solid var(--border);border-radius:8px;background:var(--card);color:var(--fg)}
  button{cursor:pointer}
  canvas{max-width:100%}
  #resultBox{margin:8px 0;padding:10px 12px;border-radius:8px;font-weight:600;border:1px solid var(--border)}
  .bullish{background:var(--good-bg);color:var(--good-fg)}
  .bearish{background:var(--bad-bg);color:var(--bad-fg)}
  .neutral{background:var(--neutral-bg);color:var(--neutral-fg)}
  .kv{display:flex;justify-content:space-between;margin:6px 0;color:var(--muted)}
  .pill{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px;margin:3px 4px;border:1px solid var(--border);background:var(--bg)}
  .pill.good{background:var(--good-bg);color:var(--good-fg)}
  .pill.bad{background:var(--bad-bg);color:var(--bad-fg)}
  .legend-sr{font-size:12px;color:var(--muted);margin-top:6px}
  #toast{position:fixed;left:50%;transform:translateX(-50%);bottom:16px;background:#111a;color:#fff;padding:8px 12px;border-radius:8px;display:none}
  #spinner{display:none;margin:6px auto 0;font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<header>
  <h1>📊 Smart Options & Technical Analyzer — Stable Release</h1>
  <div id="controls">
    <label for="ticker">Ticker:</label>
    <input id="ticker" value="IBM" size="8" autocomplete="off" />
    <button id="analyzeBtn">Analyze</button>
    <button id="copyBtn" title="Copy summary line">Copy Summary</button>
    <span id="spinner">Analyzing…</span>
  </div>
</header>

<div id="wrap">
  <div class="row">
    <div class="card">
      <h3>Price Action (6M) — Candles + DMA 20/50/200 + Auto S/R</h3>
      <div class="body">
        <div style="height:360px"><canvas id="candleChart"></canvas></div>
        <div style="height:120px;margin-top:10px"><canvas id="volChart"></canvas></div>
        <div class="legend-sr">Dashed lines = Support / Resistance (clustered)</div>
      </div>
    </div>

    <div class="card">
      <h3>Signals & Trade Bias</h3>
      <div class="body">
        <div id="resultBox" class="neutral">Waiting for analysis…</div>
        <div id="signalPills"></div>
        <div style="margin-top:10px">
          <div class="kv"><span>Trend (DMA stack):</span><strong id="kvTrend">—</strong></div>
          <div class="kv"><span>Volume Trend (10d):</span><strong id="kvVolume">—</strong></div>
          <div class="kv"><span>Latest Candle Pattern:</span><strong id="kvPattern">—</strong></div>
          <div class="kv"><span>Nearest Support / Resistance:</span><strong id="kvSR">—</strong></div>
          <div class="kv"><span>Notes:</span><span id="kvNotes">—</span></div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="toast"></div>

<script>
/* ======= CONFIG ======= */
const CONFIG = {
  cacheMinutes: 15,
  fetchTimeoutMs: 7000,
  swingLookback: 8,
  srClusterPct: 0.6,       // cluster levels within 0.6%
  srProximityPct: 1.0,     // “near” SR within 1.0%
  volRiseThresholdPct: 8,  // avg vol increase threshold (10d vs prior 10d)
  weights: { dma: 1.5, pattern: 1.0, volume: 1.0, sr: 0.5 } // weighted scoring
};

/* ======= UTIL ======= */
const $ = sel => document.querySelector(sel);
const show = (el, on=true)=>{ el.style.display = on ? 'block' : 'none'; }
const toast = (msg, ms=2500)=>{ const t=$("#toast"); t.textContent=msg; show(t,true); setTimeout(()=>show(t,false), ms); }

function validateTicker(t){
  return /^[A-Z0-9\.\-]{1,7}$/.test(t);
}

/* ======= CACHED FETCH ======= */
async function timedFetch(url, ms){
  const ctrl = new AbortController();
  const id = setTimeout(()=>ctrl.abort(), ms);
  try { return await fetch(url, { signal: ctrl.signal }); }
  finally { clearTimeout(id); }
}

async function getYahooCandleData(ticker){
  const key = `yh_${ticker}`;
  const now = Date.now();
  const cached = localStorage.getItem(key);
  if(cached){
    try{
      const obj = JSON.parse(cached);
      if(now - obj.ts < CONFIG.cacheMinutes*60*1000){
        return obj.data;
      }
    }catch{}
  }

  /*const url = `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?range=6mo&interval=1d`;
  let j;
  try{
    const res = await timedFetch(url, CONFIG.fetchTimeoutMs);
    j = await res.json();
    if(!j.chart?.result?.length) throw new Error("Empty result");
  }catch{
    // one retry
    const res2 = await timedFetch(url, CONFIG.fetchTimeoutMs);
    j = await res2.json();
  }*/

// --- PATCHED Yahoo fetch (CORS-safe) ---
const baseUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?range=6mo&interval=1d`;
const proxyUrl = "https://api.allorigins.win/raw?url=" + encodeURIComponent(baseUrl);

let j;
try {
  const res = await timedFetch(proxyUrl, CONFIG.fetchTimeoutMs);
  j = await res.json();
  if (!j.chart?.result?.length) throw new Error("Empty result");
} catch (err) {
  console.warn("Yahoo fetch failed once, retrying...", err);
  const res2 = await timedFetch(proxyUrl, CONFIG.fetchTimeoutMs);
  j = await res2.json();
}


  
  const q=j.chart.result[0]; const p=q.indicators.quote[0]; const ts=q.timestamp;
  const rows = ts.map((t,i)=>({
    x:new Date(t*1000),
    o:p.open[i], h:p.high[i], l:p.low[i], c:p.close[i], v:p.volume[i]
  })).filter(d=>Number.isFinite(d.c) && Number.isFinite(d.v));
  localStorage.setItem(key, JSON.stringify({ ts: now, data: rows }));
  return rows;
}

/* ======= INDICATORS ======= */
const Indicators = {
  sma(data,len){
    const out=[]; let sum=0, q=[];
    for(let i=0;i<data.length;i++){
      const cv=data[i].c; if(!Number.isFinite(cv)) continue;
      q.push(cv); sum+=cv;
      if(q.length>len){ sum-=q.shift(); }
      if(q.length===len) out.push({x:data[i].x, y:sum/len});
    }
    return out;
  },
  volumeTrend(data, window=10){
    const last = data.slice(-window);
    const first = data.slice(-2*window, -window);
    if(first.length<window) return {changePct:0, rising:false};
    const avgA = first.reduce((a,b)=>a+b.v,0)/first.length;
    const avgB = last.reduce((a,b)=>a+b.v,0)/last.length;
    const pct = ((avgB-avgA)/Math.max(1,avgA))*100;
    return {changePct:pct, rising: pct > CONFIG.volRiseThresholdPct};
  },
  dmaStackBias(last, ma20, ma50, ma200){
    const p = last.c, m20=ma20.at(-1)?.y ?? p, m50=ma50.at(-1)?.y ?? p, m200=ma200.at(-1)?.y ?? p;
    if(p>m20 && m20>m50 && m50>m200) return {tag:"Strong Uptrend", score:+3};
    if(p<m20 && m20<m50 && m50<m200) return {tag:"Strong Downtrend", score:-3};
    if(p>m50 && m50>m200)           return {tag:"Uptrend", score:+2};
    if(p<m50 && m50<m200)           return {tag:"Downtrend", score:-2};
    return {tag:"Sideways", score:0};
  }
};

/* ======= STRUCTURE / S/R ======= */
const Structures = {
  findSupportResistance(data, lookback=CONFIG.swingLookback){
    const sup=[], res=[];
    for(let i=lookback;i<data.length-lookback;i++){
      const lows = data.slice(i-lookback, i+lookback+1).map(d=>d.l);
      const highs= data.slice(i-lookback, i+lookback+1).map(d=>d.h);
      const low = data[i].l, high=data[i].h;
      if(low===Math.min(...lows))  sup.push({x:data[i].x, price:low});
      if(high===Math.max(...highs)) res.push({x:data[i].x, price:high});
    }
    function cluster(levels){
      const pct = CONFIG.srClusterPct/100;
      levels.sort((a,b)=>a.price-b.price);
      const out=[];
      for(const lv of levels){
        if(!out.length || Math.abs(lv.price - out.at(-1).price)/lv.price > pct){
          out.push(lv);
        }else{
          // average merge
          out[out.length-1].price = (out.at(-1).price + lv.price)/2;
        }
      }
      return out.slice(-6);
    }
    return { sup:cluster(sup), res:cluster(res) };
  },
  srProximityScore(price, sup, res){
    const prox = CONFIG.srProximityPct/100;
    const near = (levels)=>levels.reduce((best,lv)=>{
      const d=Math.abs(lv.price-price)/price; return d<best?d:best;
    }, 9e9);
    const ns = sup.length? near(sup):9e9;
    const nr = res.length? near(res):9e9;
    let score=0, note=[];
    if(ns<prox){ score += 1; note.push(`Near Support (${(ns*100).toFixed(2)}%)`); }
    if(nr<prox){ score -= 1; note.push(`Near Resistance (${(nr*100).toFixed(2)}%)`); }
    return {score, note: note.join(", ") || "—"};
  }
};

/* ======= CANDLE PATTERNS ======= */
const Patterns = {
  isBullish:c=>c.c>c.o, isBearish:c=>c.c<c.o,
  body:c=>Math.abs(c.c-c.o), range:c=>Math.max(1e-6,c.h-c.l),
  upperW:c=>c.h - Math.max(c.c,c.o), lowerW:c=>Math.min(c.c,c.o) - c.l,
  detect(prev, cur){
    if(!prev||!cur) return null;
    const body= this.body(cur), rng=this.range(cur);
    if(body <= 0.1*rng) return "Doji";
    if(this.isBearish(prev) && this.isBullish(cur) && cur.c > prev.o && cur.o < prev.c) return "Bullish Engulfing";
    if(this.isBullish(prev) && this.isBearish(cur) && cur.o > prev.c && cur.c < prev.o) return "Bearish Engulfing";
    const up=this.upperW(cur), low=this.lowerW(cur);
    if(body <= 0.35*rng && low >= 2*body && up <= body) return "Hammer";
    if(body <= 0.35*rng && up  >= 2*body && low<= body) return "Shooting Star";
    return null;
  },
  score(tag){
    if(tag==="Bullish Engulfing" || tag==="Hammer") return {score:+1, tag};
    if(tag==="Bearish Engulfing" || tag==="Shooting Star") return {score:-1, tag};
    if(tag==="Doji") return {score:0, tag:"Doji"};
    return {score:0, tag:"—"};
  }
};

/* ======= RENDERING ======= */
let candleChart=null, volChart=null;

const Renderer = {
  /*drawCandleChart(t, data, ma20, ma50, ma200, sup, res){
    candleChart?.destroy();
    const ctx = $("#candleChart").getContext("2d");
    const srDatasets = [
      ...sup.map((lv,i)=>({
        label:`Support @ ${lv.price.toFixed(2)}`, type:'line',
        data:[{x:data[0].x,y:lv.price},{x:data.at(-1).x,y:lv.price}],
        borderColor:'#2e7d32', borderDash:[6,6], borderWidth:1, pointRadius:0
      })),
      ...res.map((lv,i)=>({
        label:`Resistance @ ${lv.price.toFixed(2)}`, type:'line',
        data:[{x:data[0].x,y:lv.price},{x:data.at(-1).x,y:lv.price}],
        borderColor:'#b71c1c', borderDash:[6,6], borderWidth:1, pointRadius:0
      }))
    ];
    candleChart = new Chart(ctx,{
      type:'candlestick',
      data:{ datasets:[
        { label:t, data:data, borderColor:'rgba(0,0,0,0.7)',
          color:{up:'#4caf50',down:'#f44336',unchanged:'#9aa4b2'} },
        { label:'DMA 20', data:ma20, type:'line', borderColor:'#2196f3', borderWidth:1.5, pointRadius:0 },
        { label:'DMA 50', data:ma50, type:'line', borderColor:'#9c27b0', borderWidth:1.5, pointRadius:0 },
        { label:'DMA 200',data:ma200,type:'line', borderColor:'#ff9800', borderWidth:1.5, pointRadius:0 },
        ...srDatasets
      ]},
      options:{
        maintainAspectRatio:false,
        plugins:{ legend:{display:true}, tooltip:{mode:'index', intersect:false} },
        interaction:{mode:'index', intersect:false},
        scales:{ x:{type:'time', time:{unit:'week'}}, y:{title:{display:true,text:'Price ($)'}} }
      }
    });
  }*/
  //fixed
  drawCandleChart(t, data, ma20, ma50, ma200, sup, res){
  // --- Safe cleanup for previous chart instance ---
  if (candleChart && typeof candleChart.destroy === "function") {
    try { candleChart.destroy(); } catch(e) { console.warn("Chart cleanup", e); }
    candleChart = null;
  }

  const ctx = $("#candleChart").getContext("2d");

  const srDatasets = [
    ...sup.map(lv => ({
      label:`Support @ ${lv.price.toFixed(2)}`,
      type:'line',
      data:[{x:data[0].x, y:lv.price},{x:data.at(-1).x, y:lv.price}],
      borderColor:'#2e7d32', borderDash:[6,6], borderWidth:1, pointRadius:0
    })),
    ...res.map(lv => ({
      label:`Resistance @ ${lv.price.toFixed(2)}`,
      type:'line',
      data:[{x:data[0].x, y:lv.price},{x:data.at(-1).x, y:lv.price}],
      borderColor:'#b71c1c', borderDash:[6,6], borderWidth:1, pointRadius:0
    }))
  ];

  candleChart = new Chart(ctx, {
    type:'candlestick',
    data:{
      datasets:[
        { label:t, data:data, borderColor:'rgba(0,0,0,0.7)',
          color:{up:'#4caf50',down:'#f44336',unchanged:'#9aa4b2'} },
        { label:'DMA 20', data:ma20, type:'line', borderColor:'#2196f3', borderWidth:1.5, pointRadius:0 },
        { label:'DMA 50', data:ma50, type:'line', borderColor:'#9c27b0', borderWidth:1.5, pointRadius:0 },
        { label:'DMA 200',data:ma200,type:'line', borderColor:'#ff9800', borderWidth:1.5, pointRadius:0 },
        ...srDatasets
      ]
    },
    options:{
      maintainAspectRatio:false,
      plugins:{legend:{display:true}, tooltip:{mode:'index', intersect:false}},
      interaction:{mode:'index', intersect:false},
      scales:{
        x:{type:'time',time:{unit:'week'}},
        y:{title:{display:true,text:'Price ($)'}}
      }
    }
  });
},
//fixed
  drawVolumeChart(data){
  if (volChart && typeof volChart.destroy === "function") {
    try { volChart.destroy(); } catch(e) { console.warn("Chart cleanup", e); }
    volChart = null;
  }

  const ctx = $("#volChart").getContext("2d");

  volChart = new Chart(ctx,{
    type:'bar',
    data:{
      labels:data.map(d=>d.x),
      datasets:[{
        label:'Volume',
        data:data.map(d=>d.v),
        backgroundColor:data.map(d=>d.c>d.o
          ?'rgba(76,175,80,0.5)'
          :'rgba(244,67,54,0.5)'),
        borderWidth:0
      }]
    },
    options:{
      maintainAspectRatio:false,
      plugins:{legend:{display:false}, tooltip:{mode:'index',intersect:false}},
      interaction:{mode:'index',intersect:false},
      scales:{
        x:{display:false},
        y:{title:{display:true,text:'Volume'}}
      }
    }
  });
},

  /*drawVolumeChart(data){
    volChart?.destroy();
    const ctx = $("#volChart").getContext("2d");
    volChart = new Chart(ctx,{
      type:'bar',
      data:{ labels:data.map(d=>d.x),
        datasets:[{
          label:'Volume', data:data.map(d=>d.v),
          backgroundColor:data.map(d=>d.c>d.o?'rgba(76,175,80,0.5)':'rgba(244,67,54,0.5)'),
          borderWidth:0
        }]},
      options:{
        maintainAspectRatio:false,
        plugins:{ legend:{display:false}, tooltip:{mode:'index', intersect:false} },
        interaction:{mode:'index', intersect:false},
        scales:{ x:{display:false}, y:{title:{display:true,text:'Volume'}} }
      }
    });
  },*/
  updateSignalPanel(t, verdict, total, confidence, stack, pat, vol, srP, sup, res, patternTag){
    const box=$("#resultBox");
    box.className = verdict.cls;
    box.textContent = `${t}: ${verdict.label} — Score ${total>=0?'+':''}${total.toFixed(1)} · Confidence ${confidence}%`;

    const pills = $("#signalPills");
    pills.innerHTML = "";
    const pill = (txt,good)=>`<span class="pill ${good?'good':'bad'}">${txt}</span>`;
    const neutral = txt=>`<span class="pill">${txt}</span>`;
    pills.innerHTML += stack.score>0 ? pill(stack.tag,true) : stack.score<0 ? pill(stack.tag,false) : neutral(stack.tag);
    pills.innerHTML += pat.score>0   ? pill(pat.tag,true)   : pat.score<0   ? pill(pat.tag,false)   : neutral(pat.tag);
    pills.innerHTML += vol.score>0   ? pill(vol.tag,true)   : vol.score<0   ? pill(vol.tag,false)   : neutral(vol.tag);
    pills.innerHTML += srP.score>0   ? pill(srP.note,true)  : srP.score<0   ? pill(srP.note,false)  : neutral(srP.note);

    $("#kvTrend").textContent   = stack.tag;
    $("#kvVolume").textContent  = vol.tag;
    $("#kvPattern").textContent = patternTag || '—';
    const nearSup = sup.length ? sup.at(-1).price.toFixed(2) : '—';
    const nearRes = res.length ? res.at(-1).price.toFixed(2) : '—';
    $("#kvSR").textContent = `S: ${nearSup}  |  R: ${nearRes}`;

    const notes=[];
    if(patternTag==='Doji') notes.push('Indecision — wait for break/confirm.');
    if(srP.note.includes('Support')) notes.push('Near support: improves R/R for calls.');
    if(srP.note.includes('Resistance')) notes.push('Near resistance: wait for breakout or pullback.');
    if(vol.score>0) notes.push('Rising volume: confirms moves.');
    $("#kvNotes").textContent = notes.join(' ');
  }
};

/* ======= DECISION SUMMARY ======= */
function weightedSummary(stack, pat, vol, sr){
  const total = CONFIG.weights.dma*stack.score +
                CONFIG.weights.pattern*pat.score +
                CONFIG.weights.volume*vol.score +
                CONFIG.weights.sr*sr.score;
  const verdict = total>=3 ? {label:"Bullish", cls:"bullish"} :
                  total<=-3? {label:"Bearish", cls:"bearish"} :
                             {label:"Neutral / Wait", cls:"neutral"};
  const confidence = Math.min(100, Math.round((Math.abs(total)/6)*100));
  return {total, verdict, confidence};
}

/* ======= MAIN ======= */
let summaryLine = "";

async function analyze(){
  const ticker = $("#ticker").value.toUpperCase().trim();
  if(!validateTicker(ticker)){ toast("Invalid ticker format."); return; }

  show($("#spinner"), true);
  try{
    const data = await getYahooCandleData(ticker);
    if(data.length < 60) throw new Error("Not enough history");

    // compute indicators in parallel-ish
    const ma20 = Indicators.sma(data,20);
    const ma50 = Indicators.sma(data,50);
    const ma200= Indicators.sma(data,200);
    const last = data.at(-1), prev = data.at(-2);

    const patternTag = Patterns.detect(prev,last);
    const pat = Patterns.score(patternTag);
    const volT = Indicators.volumeTrend(data,10);
    const vol = volT.rising ? {score:+1, tag:`Rising Vol (+${volT.changePct.toFixed(1)}%)`} :
                              {score:0,  tag:`Flat/Down Vol (${volT.changePct.toFixed(1)}%)`};
    const stack = Indicators.dmaStackBias(last, ma20, ma50, ma200);
    const {sup,res} = Structures.findSupportResistance(data);
    const srP = Structures.srProximityScore(last.c, sup, res);

    const { total, verdict, confidence } = weightedSummary(stack, pat, vol, srP);

    // render
    Renderer.drawCandleChart(ticker, data, ma20, ma50, ma200, sup, res);
    Renderer.drawVolumeChart(data);
    Renderer.updateSignalPanel(ticker, verdict, total, confidence, stack, pat, vol, srP, sup, res, patternTag);

    // summary line for quick share
    summaryLine = `${ticker} — ${verdict.label} (Score ${total>=0?'+':''}${total.toFixed(1)}, Conf ${confidence}%) · Trend:${stack.tag} · Vol:${vol.tag} · Pat:${patternTag||'—'} · ${srP.note}`;
  }catch(err){
    console.error(err);
    $("#resultBox").className = "neutral";
    $("#resultBox").textContent = "Error loading data (check ticker / network).";
    toast("Failed to analyze. Try again.");
  }finally{
    show($("#spinner"), false);
  }
}

/* ======= UI HOOKS ======= */
function debounce(fn, ms=350){
  let id; return (...args)=>{ clearTimeout(id); id=setTimeout(()=>fn(...args), ms); };
}
$("#analyzeBtn").addEventListener("click", analyze);
$("#ticker").addEventListener("input", debounce(()=>{
  const t=$("#ticker").value.toUpperCase(); $("#ticker").value=t.replace(/[^A-Z0-9\.\-]/g,'');
}, 150));
$("#copyBtn").addEventListener("click", ()=>{
  if(!summaryLine){ toast("Run an analysis first."); return; }
  navigator.clipboard.writeText(summaryLine);
  toast("Summary copied!");
});

window.addEventListener("DOMContentLoaded", analyze);
</script>
</body>
</html>
